= DCS-BIOS User Guide
:toc: right
:icons: font
:toclevels: 2
:imagesdir: images

Welcome to the DCS-BIOS User Guide.

This manual will explain how you can use DCS-BIOS to connect the clickable cockpit of a DCS: World aircraft to real-world hardware such as toggle switches, push buttons, rotary encoders, potentiometers and displays.

NOTE: If you want to add a new aircraft module or use your own software with DCS-BIOS, please refer to the Developer Guide.

== Introduction

So you want to build a panel for your DCS: World aircraft.
Whether you own a CNC machine or just a drill and a hot glue gun, you probably have some idea of how to use the tools available to you to mount controls such as push buttons, toggle switches, rotary encoders and potentiometers to a faceplate.

Once you have done that, you need a way to connect these controls to your DCS: World aircraft.
If that aircraft is the A-10C, read on to find out if DCS-BIOS is right for you.

=== Why Use DCS-BIOS?

The Home Cockpit section on the ED forums provides numerous examples of how to connect a switch panel to DCS.
Is DCS-BIOS just another means of doing the same thing?  No it isn't and this is why you will want to use it.

==== DCS-BIOS is "easy to use".

You've heard of people trying to learn Lua just to write their own `Export.lua` file.
In most cases this was just an exercise in frustration.
DCS-BIOS was produced so you don't have to worry about learning how to make your own lua files.
*If you can connect two wires together, copy and paste text and follow step-by-step instructions, you can make a functioning panel.*

==== DCS-BIOS is fully documented
We understand the frustrations when you try to build something or use something that has little or no instructions.
The "DCS-BIOS Users Guide" was produced to ensure you have the help you need.
It was written in easy to understand terminology aimed specifically at the novice.
You do not have to be a programmer or an electrical engineer to understand it.
After you read this User Guide, you will be able to connect a simple switch panel to DCS.

If you do have a programming background or simply want to know more, we have a Developer's Guide that explains the internal workings of DCS-BIOS in greater detail.

==== DCS-BIOS will not impact your PC's performance
We did not notice any change in FPS when testing DCS-BIOS.
The additional computation it requires of your PC or its precious resources is negligible.

==== DCS-BIOS will protect your switch panel from ED updates
"So ed just broke my switch panel with their latest update".
DCS-BIOS will not let that happen.
In fact, DCS-BIOS was written just for that reason.
DCS-BIOS isolates your switch panel from the impact of any changes that Eagle Dynamics might introduce in an update.
In the extremely rare event that Eagle Dynamics does make a change that breaks something, we will ensure DCS-BIOS is immediately updated.
Your panels will always maintain their functionality.

==== DCS-Bios has an extremely efficient protocol design
Well what does that mean?  DCS-BIOS provides an extremely fast means of communication with DCS.
Your indicators, gauges and displays will never stutter or lag during a flurry of activity in the cockpit.
Pressing the signal lamp test button when spooling up the engines, or when half your caution lights panel is blinking after a SAM hit will have no impact on how fast your cockpit instruments respond.  

==== DCS-BIOS covers everything.
There are a variety of interface boards available that allow you to connect switches or rotary encoders or maybe even both to DCS.
DCS-BIOS however, extends way beyond any solution you might presently find.
In Fact, it is the most comprehensive means of connecting your switch panel to any combination of your DCS aircrafts' buttons, switches, rotary encoders, potentiometers, push buttons, three way switches etc., etc.
In sh-90ort, there is nothing in the cockpit that DCS-BIOS does not cover.

==== DCS-BIOS makes use of the extremely popular Arduino ecosystem
DCS-BIOS was designed to work with the http://www.arduino.cc[Arduino family of microcontroller boards.]
Why?  The choice was easy.
By using a popular, general-purpose microcontroller development board instead of designing a custom PCB, we benefit from the low cost associated with mass production and economics of scale.
Suitable boards can be bought for approximately $25 from the official Arduino store.
100% compatible clones can be purchased on eBay or Amazon for just a few dollars each.

The popularity of the Arduino platform has also spawned a huge number of online tutorials, guides and blog posts.
There is an almost endless supply of support available.
In fact, you may also find numerous other uses for it besides controlling your cockpit.

No matter what you wish to connect to your Arduino board, its more than probable someone out there has already done it and documented the results for you to use.



== Connecting your First Panel

The purpose of this next section is to demonstrate how easy it is to use DCS-BIOS to create a working switch panel and have it connect to your DCS aircraft.   


=== Before you start

The following prerequisites are necessary for the successful completion of this section:

==== Skills

* Have a basic understanding of what an *electric circuit* is.
* Know what a *short-circuit* is, why it is a Bad Thing(TM) and how to avoid creating one by accident
* Have some way to make electrical connections.
  That can mean a "breadboard" and jumper wires, a soldering iron, a wire wrap tool, ...

==== Equipment
We will assume you have access to the following:

* A computer that has DCS: World installed with access the internet and a free USB port
* An Arduino board (the http://arduino.cc/en/Main/ArduinoBoardUno[Arduino UNO] is a good choice for beginners)
* A momentary on push button (the kind that stays on as long as you are pressing it) 
* An LED (any colour and/or size) but not one of those super high powered, go blind if you look at it, types. 
* A 220ohm 1/4 watt resistor
* 24 gauge wire or jumper wires

=== Our Step by Step Instructions:
==== Step 1: Setting up DCS-BIOS

1.1 Download the latest release of DCS-BIOS from https://github.com/jboecker/dcs-bios/releases[GitHub] and extract the ZIP file somewhere on your hard drive

1.2 Open a new Explorer window (for example by opening "My Computer"), paste the following into the address bar and press return:
----
%USERPROFILE%\Saved Games\DCS
----
This should take you to your DCS configuration folder (it has several subfolders including `Logs` and `Missions`).
You are looking for the `scripts folder`.
(Not all configurations will have a scripts folder.
Do not be concerned if you don`t have one.
Just follow these steps.)

1.3 If you see a scripts folder, stop reading and go directly to step 1.4.
If you don't see a `Scripts` subfolder don't worry as we will provide one for you.
Go back to where you extracted DCS-BIOS and copy our `Scripts` folder (and its contents) from there and paste it into your Saved Games\DCS directory.
You now have a scripts folder and can skip step 1.4 and 1.5.  Go directly to step 1.6.

1.4 This step is for all those folks that already have a scripts folder, but...
You have an existing scripts folder and we want you to add some files to it that we have provided.
To do that you must go back to where you extracted DCS-BIOS and copy *just the contents* of our scripts folder and paste it into your existing scripts folder with the exception of the "export.lua file".

NOTE: The contents of our scripts folder includes a copy of our export.lua file.  If you already have an existing export.lua file in your scripts folder, we don't want you overwriting it with our export.lua file.  

So check first and see if you have one.
If you do, then read no further and go immediately to step 1.5.
If you don't have one, then we will provide one for you.
Go back to where you extracted DCS-BIOS to and find our export.lua file (in the scripts folder of course).
Copy it and then paste it into your scripts folder.
Because you are now going to use our export.lua file, you can skip step 1.5 and go immediately to step 1.6.


1.5 "I already have an export.lua file in my scripts folder" which you are now going to edit.
If editing a file is new to you, do not be concerned.  Just follow these steps.
 
* Download `Notepad++`from http://notepad-plus-plus.org/download/v6.6.9.html
and install it onto your PC.  This program is designed to edit files.
  
NOTE: You should never use any word processing software to edit files.  These type of programs leave their own coding behind.  This can result in file that no longer functions as intended.

* Once Notepad++ is installed on your PC, start it and open your existing `Export.lua` file.  Copy the single line below and paste it into the lua file.
It should be the very last line in your export.lua file.

[source,lua]
----
dofile(lfs.writedir()..[[Scripts\DCS-BIOS\BIOS.lua]])
----
* Save the file and continue on to step 1.6.

 
1.6 *DCS-BIOS is installed and enabled.*  You may now move to Step 2. 


==== Step 2: Connecting your LED and Push Button Switch

Before you start plugging in wires and resistors, take a few minutes and have a look at the Arduino board you are using.  Get familiar with the pin designations printed on your board. It would be well worthwhile spending a few minutes on the Arduino web site and do a bit of reading on the basics of using Arduino boards.  There are numerous YouTube videos that will introduce you to the world of Arduino.
This will all help as you move forward to more complex types panels.  So lets start...

2.1  Connect your push button switch to your Arduino board at pin 10 and pin GND (ground).

NOTE: There are several pins designated as GND (ground) on the board.  They are all connected together. It doesn't matter which one you choose.

2.2 Connect your LED and current limiting resistor to the Arduino board at pin 13 and pin GND (ground). Pay attention to the polarity of the LED before you connect it. The cathode, which is the negative side always goes to pin GND. Nothing will start smoking if you connect it backwards. It just won't work until its connected properly.

When complete your curcuit should look like this:

image::uno1.jpg[651, 651]



* Plug your Arduino board into a USB port.
  If any drivers are required there will be instructions as to how to install them.
  It does vary between Arduino boards but it's no different really than installing a headset or joystick.
  The USB port provides power to the Arduino board but you can use a wallwart providing its 12v.
  There is an onboard jack to plug into.

*You have now completed all of the required wiring for you first switch panel.*

NOTE: The USB port provides power to the Arduino board but many boards also have a jack that allows you use an external power supply such as a wallwart providing it supplies 12v and the centre pin is positive. 



==== Step 3: Set up the Arduino IDE
I imagine your next question is "what is an IDE".
The Arduino IDE is a program that you will download and install on to your PC.
It is similar to a word processing program except this it is used to write small programs (they are called sketches) and upload them to your Arduino board.
You should probably read the page describing how to use the IDE on the Arduino web site.
It is very simple and you should have little to no difficulty understanding what to do.
So to continue...
   
. Download and install the Arduino IDE http://arduino.cc/en/Main/Software[from the Arduino website.]

The Arduino IDE uses what are referred to as "Libraries" to help you make various types of devices work properly using a minimum of commands.
There are libraries for using LCD displays, stepper motors, servos etc.
It's a long list.
We have produced such a library for using DCS-BIOS and it is called the DCS-BIOS Arduino library.
As with all libraries, it was developed to make your life easier when it comes to writing a sketch.
However, libraries need to be installed and this next step will guide you through that process.

* Download the https://github.com/dcs-bios/dcs-bios-arduino-library/releases[DCS-BIOS Arduino library] from GitHub.
DO NOT extract it.
It also doesn't matter where you download the file to as long as YOU know where it is as you will need to point to its location in the next step.

* Start the Arduino IDE
* Click `Sketch -> Import Library -> Add Library...` and then go find the ZIP file you downloaded "DCS-BIOS Arduino library.zip" and select it.  The Arduino IDE will do the rest.
That's all there is to importing libraries into the IDE.

* Close and re-open your Arduino IDE.
You are now ready to start you first sketch.

==== Step 4: Create a skecth for your Arduino board
*Congratulations, you have completed all of the one-time setup steps.*

From now on any panel that you create will only require you to complete following set of instructions.


==== Step 4: Create a sketch for your Arduino board



You are now going to create a sketch for your Arduino board that connects it to DCS and makes you switch and LED work as in your DCS aircraft cockpit.
In order to simplify this process you will begin your sketch by opening a "template" that we have provided.
Until such day as you become an Arduino programming expert you will start every new sketch with this template.
It provides all of the essential code necessary to communicate with DCS.
It automatically reads the state of your connected switches and reports this to DCS-BIOS which then updates the switches of your DCS aircraft.
 
Another function of this template is to automatically gather output data from DCS.
You can use this data to make gauges function, displays work or indicator lights to light up.
We will provide you with several examples in the appendix.


NOTE: Take special care not to alter any of the existing code that comes with this template as you work on your sketch.  

==== So lets begin:

* Click `File -> Examples -> DcsBios -> TemplateSketch` to open the template program that comes with the DCS-BIOS Arduino library.

To develop a sketch for your panel, you are going to copy snippets or lines of code from a reference document that we have provided.

* Go to your saved Games folder/DCS-BIOS/doc and double-click on the file `control-reference.html` 
Your web browser will automatically open and either display all sorts of colorful headings and code or you will see a red warning followed by a bunch of nonsense.
In that case you need to enable JavaScript in your web browser and reload the page.
There is usually a box at the bottom of your screen that appears and asks you if you want to display "active content".
You need to say yes.

This web page is the reference document we are referring too.
It lists every single DCS module (Only the A10 for now but it will) and every single panel found in that aircraft and every single corresponding switch, push button and rotary knob or whatever assoicated with that panel and the corresponding code that you will use to create your "Sketch".
This is one huge document, or at least it will be when its complete.
 
You will find along the top of the web page, "filters" in the form of drop down menus that can be use to display precisely what you are looking for.
You have the choice of what aircraft you would like to work with (The A10 is your only choice at the moment), the type of information you would like displayed (basic or advanced) and every single panel on the aircraft you chose to work with.
Stay away from the advanced tab until you know what you are doing.
And finally there is the filter thats lets you display information on the panel of your choice.

* Set your filters accordingly for the Up Front Controller

The first entry should be the one for the Master Caution Light.

* just left click in the box with the yellow background and then right click and choose "Copy".
Now move to the Arduino IDE and paste this line in the space just below where it says "paste your code below here".   

* Now go back to the control-reference web page. Scroll down a bit until you come to the `UFC_MASTER_CAUTION / Master Caution Reset` entry.

* As before, left click in the box with the yellow background and then right click and choose "Copy".
Move to the Arduino IDE and paste this line in the space below the last one.

Did you notice the red highlighting in the control-reference document?  It highlights the word "PIN" or "PIN_A, PIN_B" etc.
These are temporary placeholders that you will be changing.  

* Lets start with the switch that you are using to reset the Master Caution.  You attached it to Pin 10 on the Arduino board.
You now need to go into the Arduino IDE, to the line of code you pasted for the Master Caution Reset switch.  Change the placeholder "PIN"  to the pin that switch is connected to.  In this particular case it was Pin 10.  The word "PIN' gets replaced with 10.  The line of code for the Master Caution switch should have changed as follows:
[source,c++]
----
DcsBios::Switch2 ufcMasterCaution("UFC_MASTER_CAUTION", PIN);
DcsBios::Switch2 ufcMasterCaution("UFC_MASTER_CAUTION", 10);  
---- 

* You now do the same for the LED that respresents the Master Caution warning.  As before, you go into the Arduino IDE, to the line of code you pasted for it.  Change the word "PIN" to the pin number you connected the LED to.  The word "PIN' gets replaced with 13.  The line of code for the LED Master Caution warning should change as follows:
[source,c++]
----
DcsBios::LED masterCaution(0x108e, 0x0008, PIN); 
DcsBios::LED masterCaution(0x108e, 0x0008, 13);
----
When you have completed these changes your sketch should look like this:
[source,c++]
----
#include <DcsBios.h>
#include <Servo.h>

/**** Paste your code below here ****/

DcsBios::LED masterCaution(0x108e, 0x0008, 13);
DcsBios::Switch2 ufcMasterCaution("UFC_MASTER_CAUTION", 10);

/**** Do not change anything below this line ****/

----
* Click `File -> Save As` to save it under a new name.

NOTE: The Arduino IDE prevents you from saving changes to a library example.
You will have to save your changes under a new name.

*Your sketch is now finished and ready for the next step.*



==== Step 5: Copy your program to your Arduino board

Now that your sketch is done, you need to load it onto your Arduino board.

The specifics of this process may vary slightly for different Arduino boards but for the most part they all follow the same basic routine.  We use the Arduino UNO in all of our examples.  

* With your sketch open in the Arduino IDE you need to tell the IDE what board you are using.  Do this by Clicking on `Tools -> Board` and then select your board from the list that is displayed.
* Next, you will need to specify the COM port your board is connected to.  Click `Tools -> Port` and select the port from the list.


NOTE: If you are unsure of the port number, it is identified in the `Control Panel/Devices and Printers` page. 

* The final step is to initiate the upload. This is done by clicking on the Arrow in the circle just below the Edit drop down menu.  When the upload begins a green bar will apear and show the progress of the upload.  When it disappears the upload is complete.  

NOTE: The Arduino website has http://arduino.cc/en/Guide/HomePage[step-by-step instructions for each board.] 

* After loading your program onto your Arduino board, you can close the Arduino software.

==== Step 6: Test your new panel

DCS-BIOS comes with a script that automatically connects a serial port to DCS. This  serial port is means by which DCS and your Arduino Board communicate.  To initiated this connection you need specify the COM Port to use.  You will use the same COM Port that the Arduino IDE used to program your board.  To begin... 

* Start Notepad++.  Open the`connect-serial-port.cmd` file which is in the DCS-BIOS folder you previously downloaded.  With the file on the screen the second line will read as:
----
set COMPORT=5
----
* Replace the number 5 with the COM port number that your Arduino board is connected to. 
 
* Save the file and close Notepad++.

* Double-click `connect-serial-port.cmd`.
A console window should pop up.
Leave it open.

*You can now start DCS and try your new panel in action!*

==== Summary
You can make any panel you like using this template file.
 
* Add the lines of code from the `control-reference.html` documentation to your sketch for the switches and or LED's you wish to use.
  
* Upload that sketch to your Arduino board.
 
* Connect the appropriate switch type and/or LED to the appropriate pin number on the Arduino board.

* Initiate the serial connection to DCS.

* Begin using your switches and LED's in you DCS aircraft.

*It can't get much easier then that.*  

==== What this Guide *IS NOT*
If your intent is to include displays and/or analog gauges with your panels you will need to have additional programming knowledge.  There are displays in the aircraft that could incorporate LCD displays, LED displays or OLED displays.  In addition there are analog Gauges in the cockpit that could be built using stepper motors, servos's or even air core motors. With such a wide choice of components available,  it really is beyond the scope of this particular document to provide instruction on every possible solution.



==== In Conclusion...

What we are providing is the means to allow any novice cockpit builder to create a functioning switch panel and/or LED Indicators that will interact with their DCS aircraft.  Most importantly, you do not need to be a programmer or electronic engineer to accomplish this task.  With DCS-BIOS, it's straight forward. It's easy and it's the begining.




==== Prolog
For those cockpit builders who would like to take there builds to the next level, DCS-BIOS is already providing every bit of the export data that you would need. It"s all there just waiting for you to make use of it.  All you will need to do is read this next section and decide by what means you wish to output the data.  There is an appendix to this document that details some of the more popular components and how they were included in the construction of a gauge, panel or display.  You will find examples of builds that document the code used, the components and the printed circuit boards that were developed. We also include a large photo library to help visualize how things went together. 
 
We very much hope DCS-BIOS will provide all of your cockpits needs.  We beleive it is the single most important instrument that removes all of those old obsticles that never let you move forward and realize your dreams.









== A Closer Look at The DCS-BIOS Arduino Library

This tutorial will show you how to read the DCS-BIOS control-reference documentation to create a sketch for any panel in the cockpit.

It will cover all of the different control types that are supported by the Arduino library.
The information provided at this point may require some level of knowledge with Arduino programming.

=== The MasterCaution Example Sketch

This section takes a closer look at the different parts of the MasterCaution example sketch. 

[source,c++]
----
#include <DcsBios.h> // <1>
#include <Servo.h>

/* paste your code below this line */ // <2>
DcsBios::Switch2 masterCautionBtn("UFC_MASTER_CAUTION", 10);
DcsBios::LED mcLed(0x108e, 0x0008, 13);

/* Do Not change anything below this line unless you know what you are doing */
DcsBios::ProtocolParser parser; // <3>

void setup() {
  Serial.begin(500000); // <4>
}

void loop() {
    while (Serial.available()) {
      parser.processChar(Serial.read()); // <5>
  }
  
    DcsBios::PollingInput::pollInputs(); // <6>
}


void sendDcsBiosMessage(const char* msg, const char* arg) { // <7>
  Serial.write(msg);
  Serial.write(' ');
  Serial.write(arg);
  Serial.write('\n');
}

void onDcsBiosWrite(unsigned int address, unsigned int value) { // <8>
  
}
----

<1> These are libraries that have been included to make you sketch function apropriately.  
They are always placed at the beginning of a sketch.  
It ensures that the Arduino IDE will bring in the required libraries when it compilies your sketch for uploading to your board.  
In addition to the `DCS-BIOS.h` library you will also see that the `Servo.h` library has been included.
Please take note that even if your sketch does not use the `ServoOutput` class of controls you still have to include `Servo.h`. 
Otherwise your sketch will fail to load.

<2> This is the code you have cut and pasted from the control-reference document.  It tells the library what types of controls you are connecting to your Arduino board.
DCS-BIOS knows how to handle push buttons, toggle switches, rotary encoders, rotary switches, potentiometers, LEDs and servo motors.
The Arduino Library Reference (below) documents all of the controls that are available to use. 


<3> Create an object of type `DcsBios::ProtocolParser`.
This is code that you need not be concerned with other than you should not change it.
<4> This line tells the Arduino board at what speed communication will take place.
This setting needs to match the one in `connect-serial-port.cmd`.
500000 is the fastest the Arduino can handle and is the default.  
You will probably not need to adjust this whatsoever .
<5> This statement creates a `loop()` so the Arduino will continually read data from DCS. It then sends it to the `DcsBios::ProtocolParser` for additional processing.
<6> DcsBios::PollingInput::pollInputs()` causes the DCS-BIOS library to check the state of all of your connected push buttons, toggle switches, rotary encoders, etc. If it finds that something has changed it sends a message to DCS to initiate that same change.  
You push your button...DCS shows that button being pushed.
<7> This line is used to tell the Arduino to communicate via "serial port".
Its nothing you will need to change.
It can, however, be modified so you can use TCP or UDP to communicate.
We anticiapte a majority of installation will probably use a serial port.
<8> Data that the Ardiuno has receievd from DCS can be sent out to physical displays.
Such display might include LED displays, LCD displays, Gauges etc.
This is the line that you would modify to obtain that data.
However, even if you do not intend to display anything you still must include this function.
If you do not, your sketch will fail to upload.  
The code required to obtain the data you wish to display is found in the "Control-Reference" document. 

=== Using the Reference Documentation
Recall the following part from the MasterCaution example:
[source,c++]
----
DcsBios::Switch2 masterCautionBtn("UFC_MASTER_CAUTION", 10);
DcsBios::LED masterCautionLED("MASTER_CAUTION", 13);
----

Unless you are doing something more advanced such as using something other than a serial port to talk to your DCS computer, this is the only part you need be concerned with.

Even without knowing much about DCS-BIOS, you might have guessed that this says there is a push button connected to pin 10 that should operate the master caution button and that the LED on pin 13 should light up then the master caution button does.

But how do you know what to put here for other controls?
You will have to consult the "Control-Reference" documentation.

==== Locating the Reference Documentation

The Control-Reference documentation is included in the `doc/` subdirectory in the DCS-BIOS download.
Simply double-click `Control-Reference.html` to open it in your web browser.

NOTE: If you see a red warning at the top of the page followed by a bunch of gibberish, you need to enable JavaScript and reload the page.

==== Finding the Control You Are Looking For

Use the search boxes at the top of the page to quickly find what you are looking for.
You can filter by category, identifier and description.

==== Supported Controls
DCS-BIOS refers to switches, rotary encoders, potentiometers, push buttons etc. as " CONTROLS".
The following are all of the supported Controls available in DCS-BIOS:

* `DcsBios::ActionButton`

* `DcsBios::Switch2`.  defines a 2 position swich

* `DcsBios::Switch3`. defines a 3 position switch

* `DcsBios::RotarySwitch`. defines a rotary switch, you provide how many positions

* `DcsBios::potentiometer`. defines a potentiometer

* `DcsBios::RotaryEncoder`. defines a rotary encoder

DCS-BIOS also includes indicator LED's in the Controls as follows:

* `DcsBios::LED`. defines an LED

Each control is identified by a unique identifier and is associated with a category, which is usually the panel it is found on in the DCS aircraft cockpit.

.example:
`DcsBios::Switch2 ahcpCicu("AHCP_CICU", PIN);` 

* whereas `ahcpCicu` indicates the CICU switch on the AHCP panel.  

* The first notation between the brackets `"AHCP_CICU"` is a placeholder for a piece of data that gets sent to DCS when a change occurs to a pin on the Arduino board.  

* The second notation `PIN` is also a placeholder however, you have to replace it with the pin number that your control is attached to.  In the Control-Reference document, placeholder that require you to assign a specific pin number to are always highlighted in"RED"
There also a few knobs/switches in your cockpit represented with two separate controls.
For example, the volume controls on the A-10C intercom panel have one DCS-BIOS control for the volume and a separate control for the mute function.

==== Input Interfaces

NOTE: To make sense of the following, change the reference documentation to "advanced view".

An _input interface_ allows you to control something in the cockpit by sending a message to DCS-BIOS.
Each DCS-BIOS control can support multiple _input interfaces_.
For example, you can toggle the CICU switch in the A-10C by sending `AHCP_CICU TOGGLE`.

A message starts with the identifier of the control you want to manipulate, followed by a space, an _argument_, and a semi-colon.
Different input interfaces understand different arguments.

Depending on the type of input interface, the reference documentation will offer different pieces of example code.


.Types of input interfaces

set_state:: If a control supports the _set_state_ interface, its current state can be set by sending it a number as an argument.
For example, you can set the TACAN mode dial in the A-10C to the `A A REC` position by sending `TACAN_MODE 3`.
+
NOTE: The range of acceptable values is 0 to the maximum value of the control's first output.
+
The reference documentation will offer example code for a `DcsBios::RotarySwitch` and (in the case of two-position controls) a `DcsBios::Switch2`.

fixed_step:: If a control supports the _fixed_step_ interface, you can increase its position with an `INC` argument and decrease its position with an `DEC` argument. A rotary encoder used to change the frequency of a VHF radio for be an appropriate example. 
+
The reference documentation will offer example code for a `DcsBios::RotaryEncoder`.

action:: This represents an action such as toggling a toggle switch or changing the X/Y digit of the TACAN channel.
+
The reference documentation will offer example code for a `DcsBios::ActionButton`.

variable_step:: If a control supports the _variable_step_ interface, you can increase or decrease its position by a certain amount by sending `+NUMBER` or `-NUMBER` as an argument, where `NUMBER` is an integer.
+
The reference documentation will offer example code for a `DcsBios::RotaryEncoder`.
The default step size is 3200.
You will need to experiment to get the right sensitivity.


==== Outputs

Each DCS-BIOS control can have multiple related _outputs_.
An _output_ represents a piece of information that is exported from DCS, for example the position of the flaps position indicator.

Outputs come in two types:

Integer outputs:: Most outputs are integers.
Each integer output has an associated maximum value and a minimum value of 0.
+
The reference documentation will offer code examples for `DcsBios::LED` and `DcsBios::ServoOutput` where appropriate.
+
The first code snippet for integer outputs is meant to be inserted into the `onDcsBiosWrite` function if the DCS-BIOS Arduino library cannot do what you want.
It shows you how to extract the value using the _mask_ and _shift_ values of the output.
+
NOTE: To learn about the meaning of the _address_, _mask_ and _shift_ value of an output, please refer to the developer guide.

String outputs:: Some values (such as radio frequencies) are exported as character strings.
The reference documentation will provide a code example that uses a `DcsBios::StringBuffer` to execute a piece of code whenever the value changes.
+
NOTE: Because there are many different types of displays (7-segment, character, graphical) and different ways to connect them to a microcontroller (direct, I2C, SPI), the DcsBios library does not include code to handle them.
For most common combinations of display type and connection method, you can find other Arduino libraries online that allow you to talk to them.


==== Copy and Paste Example Code

To use the example code from the reference documentation in your Arduino sketch, you first have to choose which code example to copy.
That depends on what type of control you want to connect.

For example, you might want to use a rotary switch for the TACAN mode dial in the A-10C and use the `DcsBios::RotarySwitch` code snippet.
For the same control, you could also choose to use a rotary encoder.

After choosing a code example, copy it to your Arduino sketch (refer back to the MasterCaution example to see where to copy it) and replace all the parts in red with your own values (usually the pin numbers that this control is connected to).

Refer to the next section for more detailed information on the individual classes, including example circuits.

== Arduino Library Reference
=== ActionButton

[source,c++]
----
DcsBios::ActionButton(char* message, char* argument, char* pin)
----

The ActionButton class is used to send a single command to DCS when its input pin goes low.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
argument:: The argument that should be sent.
pin:: The number of the Arduino pin the button is connected to.

.Circuit
Connect a push button between the Arduino pin 10 and ground.

image::uno2.jpg[500, 500]

The button on pin 10 toggles the CICU switch

.Reference Documentation Code Example
[source,c++]
----
DcsBios::ActionButton ahcpCicuToggle("AHCP_CICU", "TOGGLE", PIN);
----

.Code Examples
[source,c++]
----
DcsBios::ActionButton ahcpCicuToggle("AHCP_CICU", "TOGGLE", 10);  
----
 



=== Switch2

[source,c++]
----
DcsBios::Switch2(char* message, char pin)
----

The Switch2 class handles inputs that have two states, such as toggle switches and push buttons.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pin:: The number of the Arduino pin the button or switch is connected to

.Circuit
Connect the toggle switch or push button between the Arduino pin and ground.

.Reference Documentation Code Examples
[source,c++]
----
DcsBios::Switch2 ahcpCicu("AHCP_CICU", PIN);
----

[source,c++]
----
DcsBios::Switch2 ufcHack("UFC_HACK", PIN);
----

=== Switch3

[source,c++]
----
DcsBios::Switch3(char* message, char pinA, char pinB)
----

The Switch3 class handles inputs that have three states, such as three-position toggle switches or rotaries.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pinA:: The number of the Arduino pin that the *first switch position* is connected to
pinB:: The number of the Arduino pin that the *last switch position* is connected to

.Circuit
Connect your three-position toggle or rotary switch so that the first (left or down) position connects *pinA* to ground and the last (right or up) position connects *pinB* to ground.

The Switch3 class defaults to the center position, so (if your switch even has a pin for that) you don't have to connect it to anything.

image::toggle.jpg[500, 500]

.Reference Documentation Code Examples
[source,c++]
----
DcsBios::Switch3 aapSteer("AAP_STEER", PIN_A, PIN_B);
----

=== RotarySwitch

[source,c++]
----
DcsBios::RotarySwitch(char* message, const byte* pins, char numberOfPins);
----

The RotarySwitch class handles rotary switches.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pins:: An array of pin numbers that the rotary switch positions are connected to.
The first pin number corresponds to state 0 of the input, the second to state 1, etc.
numberOfPins:: The length of the array passed in the `pins` parameter.

.Circuit
Connect the rotary switch so that it connects the Arduino pin for the currently selected position to ground.

.Reference Documentation Code Examples
[source,c++]
----
const byte aapSteerptPins[3] = {PIN_0, ... ,PIN_2};
DcsBios::RotarySwitch aapSteerpt("AAP_STEERPT", aapSteerptPins, 3);
----

.Example
[source,c++]
----
// A rotary switch that controls the A-10C steerpoint mode (FLTPLAN / MARK / MISSION)
// is connected to digital pins 10, 11 and 12
const byte aapSteerptPins[3] = {10, 11, 12};
DcsBios::RotarySwitch aapSteerpt("AAP_STEERPT", aapSteerptPins, 3);
----

=== Potentiometer

[source,c++]
----
DcsBios::Potentiometer(char* message, char pin);
----

The Potentiometer class handles potentiometers connected to an analog pin.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
pin:: The number of the pin that is connected to the potentiometer.

.Circuit
Connect the outer pins of the potentiometer to +5V and ground.
Connect the middle pin to the Arduino.

image::DCS-BIOSpotentiometer.png[500, 500]

To reverse the direction, swap +5V and GND.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::Potentiometer cmscBrt("CMSC_BRT", PIN);
----

=== RotaryEncoder

[source,c++]
----
DcsBios::RotaryEncoder(const char* message, const char* decArg, const char* incArg, char pinA, char pinB);
----

The RotaryEncoder class handles standard rotary encoders, 2-bit grey code, 20 position detents.

.Constructor Parameters
message:: The message that should be sent. Set this to the identifier of the control.
decArg:: The argument that should be sent when the encoder is turned one step to the left.
incArg:: The argument that should be sent when the encoder is turned one step to the right.
pinA:: The first pin that is connected to the encoder.
pinB:: The second pin that is connected to the encoder.

.Circuit
Rotary encoders usually have three pins (the ones with an integrated push button have two extra pins for a momentary on push button).
Connect the left pin and right pins to any two of the Arduino pins 2 through 12, A0 through A5, and the middle pin to ground. If you find it is functioning opposite to what you want you can just swap Pin A and B on the board or in the sketch.

image::DCSBIOSrotaryencoder.png[500, 500]

To reverse the direction, either swap decArg and incArg or swap pinA and pinB.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::RotaryEncoder tacan1("TACAN_1", "DEC", "INC", PIN_A, PIN_B);
----


=== LED

[source,c++]
----
DcsBios::LED(unsigned int address, unsigned int mask, char pin)
----

The LED class is used for indicator lights.

.Constructor Parameters
address:: The address of the integer output
mask:: The mask of the integer output
pin:: The number of the Arduino pin that the LED (and current-limiting resistor) are connected to. Prior to connecting multiple LED's to your Arduino board, it would be advisable to read the section on LED's on the Arduino web site.  

.Circuit

image::LED.png[500, 500]

.Reference Documentation Code Example
[source,c++]
----
DcsBios::LED tacanTest(0x10ca, 0x0400, PIN);
----

NOTE: Arduino boards are only capable of providing 40mA of current per pin.
Multiple LED's connected to a single pin will require additional circuitry to avoid damaging the board.



=== ServoOutput

[source,c++]
----
DcsBios::ServoOutput (unsigned int address, char pin, int minPulseWidth, int maxPulseWidth)
----
.Circuit
Servos have 3 wires which are black, red and orange or yellow.
Black and red are for 5V power in.
The orange or yellow wire is the signal and must be plugged into one of the PWM pins having the ~designation. On the Uno those pins are ~3, ~5, ~6, ~9, ~10, ~11. 

image::DCSBIOSservo.png[500, 500]

The ServoOutput class handles standard "hobby servos".

.Constructor Parameters
address:: The address of the integer output
pin:: The number of the Arduino pin that is connected to the servo's control input
minPulseWidth:: The pulse width (in microseconds) that corresponds to the lowest servo position
maxPulseWidth:: The pulse width (in microseconds) that corresponds to the highest servo position

A DCS-BIOS output value of 0 will be mapped to `minPulseWidth`, the maximum output value of 65535 will be mapped to `maxPulseWidth`.
You will have to choose these values so that the minimum and maximum positions are at the beginning and end of your gauge's scale.

.Reference Documentation Code Example
[source,c++]
----
DcsBios::ServoOutput vvi(0x106e, PIN, 544, 2400);
----

NOTE: Servos are devices which have the potential to demand more current than a single Arduino board can safely provide.  Connecting multiple servos to one Aduino board will require an external power supply. Further reading at the Arduino site will be required to ensure the board does not get damaged.

=== StringBuffer

[source,c++]
----
DcsBios::StringBuffer<MAXLENGTH>(unsigned int address, void (*)(char*) callback)
----

The StringBuffer class is used to handle string outputs.

.Constructor Parameters
MAXLENGTH:: The maximum length of the string output
address:: The address of the string output
callback:: A function which accepts an argument of type `char*`.
This function will be called whenever the string output has changed.
It will be passed the new value as an argument.

.Reference Documentation Code Example
[source,c++]
----
void onUhfFrequencyChange(char* newValue) {
    /* your code here */
}
DcsBios::StringBuffer<7> uhfFrequencyBuffer(0x1170, onUhfFrequencyChange);
----

== Aircraft-Specific Notes
=== A-10C

==== CMSP, CMSC and UHF Frequency Export in external view

These values will not be updated by DCS when the cockpit is not rendered (e.g. in external view or HUD-only view).

The solution is to assign another viewport to these indicators (through MonitorSetup.lua), so they exist even when the cockpit is not shown.
You can make the viewport 1x1 pixels in size and place it outside of your visible screen area.
For example, if you have no monitor above the primary one, you could place the viewport at coordinates (0, -10).

==== Using a LED matrix for the Caution Lights

If you are building the Caution Lights panel, you probably don't want to use several Arduinos to get 48 output pins.
You want to use a LED matrix design instead.

Fortunately, the caution lights data is located in three consecutive 16-bit integers in the DCS-BIOS export address space.
The following code should get you started:

[source,c++]
----
void updateCautionLights(unsigned int address, unsigned int data) {
    unsigned char row = (address - 0x10c4) * 2;
    unsigned char column = 0;
    unsigned char i;
    bool is_on;
    for (i=0; i<16; i++) {
        is_on = data & 0x01;
        // set caution light state (row, column, is_on)
        data >>= 1;
        column++;
        if (column == 4) {
           row++;
           column = 0;
        }
    }
}
void onDcsBiosWrite(unsigned int address, unsigned int data) {
    if (address >= 0x10c4 && address <= 0x10c8) {
       updateCautionLights(address, data);
    }
}
----
